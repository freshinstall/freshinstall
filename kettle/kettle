#!/usr/bin/python3

## kettle - Desktop software configuration manager
# Copyright (c) 2018, Ian Santopietro <isantop@gmail.com>
# All rights reserved.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# kettle - main program

import logging, argparse, os   # These are extra modules that extend the functionality of the language
import  gettext                # This module is explicitly for translations
_ = gettext.gettext            # This is required for setting up the translations

from kettle import action, ket # From the kettle package (this folder), import the action and ket modules (action.py, ket.py)

# Below here is where we actually run things:

# This is a function. It does something. It's analagous to a function.
# This one is run when the user wants to create a kettle.
def create(log, path=None, extract_dir=None):
    # Create a kettle from a path. Arguments:
    # log         : The logging module for text output
    # path        : The path to the folder to create the Kettle from.
    # extract_dir : This argument isn't used for this function, but is specified in case we get it from our caller.

    log.info(_('Creating new kettle: %s' % path)) # Use log.info and log.debug to print output to the command line.

    # try/except are used when we expect an action might fail to catch that failure and inform the user what went wrong.
    try:                               # First, you put the code you think might fail after the "try" statement
        kettle = ket.NewKettle(path)   # In this case, we're trying to create a new kettle object using the NewKettle.
    except Exception as e:             # If we fail, we need to catch that error (exception)
        log.exception(e)               # Tell the user what happened
        exit()                         # Quit back to the command line, so the user can try again

    # If we can create the NewKettle object, we should be good.
    act = action.Action(kettle)   # Now we create a new action object called act, which gets the kettle we created as an argument
    act.create(path)              # And we run the create function of that action, which actually takes care of making the new kettle.


def extract(log, path=None, extract_dir=None):
    # Extract an existing kettle to a directory. Arguments:
    # log         : The logging module for text output
    # path        : The path to the kettle file to extract.
    # extract_dir : The name of the directory to extract the kettle to.

    # Another try/except block. We do these in case the user points us to a kettle that doesn't exist
    try:
        kettle = ket.Kettle(path) # This time we're using the normal Kettle class, since it exists already.
    except Exception as e:
        log.exception(e)
        exit()

    # Next we extract the kettle. First we use the log to tell the user:
    log.info(_('Extracting kettle %s from %s' % (kettle.get_id(), path)))
    act = action.Action(kettle)             # Then we create another new Action class object
    act.extract(path=extract_dir)           # And we use the extract method of the Action class


def install(log, path=None, extract_dir=None):
    # Install a kettle into the system. Arguments:
    # Extract an existing kettle to a directory. Arguments:
    # log         : The logging module for text output
    # path        : The path to the kettle file to extract.
    # extract_dir : Unused in this function

    # See how any time we do something that could result in an exception, we put is in this block?
    try:
        kettle = ket.Kettle(path)
    except Exception as e:
        log.exception(e)
        exit()

    # Basically the same structure as the extraction function, but using the install function
    log.info(_('installing kettle %s from %s' % (kettle.ketid, path)))
    act = action.Action(kettle)
    act.install(kettle)


def gui(log, path=None):
    # This function isn't used yet.
    log.info(_('Running the GUI'))
    log.exception(_('The GUI is not yet implemented, Please use the CLI instead.')) #Quit with an error that tells the user what to do.

def main():
    # main() is the primary function of the program. If you run the program from
    # the command line (or the python interpreter), this is what will run.

    # Set up some basic logging. This creates the logging object that we'll use throughout the program.
    log = logging.getLogger('kettle')
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s %(name)-14s %(levelname)-8s %(message)s')
    handler.setFormatter(formatter)
    log.addHandler(handler)
    log.setLevel(logging.DEBUG)
    log.debug(_("Logging set up!"))

    directory=None

    # Argument processing
    # parser is the argument interpreter for the program. We create it as a new
    # ArgumentParser class with some information to give the user some helpful
    # advice if they run kettle without any arguments or with --help.
    parser = argparse.ArgumentParser(prog="kettle",
                                     description=_('Desktop configuration manager'),
                                     )
    # Here we add the arguments that kettle uses.
    parser.add_argument('action',
                        nargs='?',
                        default='gui',
                        help=_('What action to do.'),
                        metavar='COMMAND',
                        )
    parser.add_argument('file',
                        nargs='?',
                        default=os.getcwd(),
                        help=_('The path to operate with. Defaults to current directory.'),
                        metavar='PATH',
                        )
    parser.add_argument('-d', '--directory',
                        default=None,
                        type=str,
                        help=_('The directory to extract the kettle to or create it from.'),
                        dest=directory,
                        )
    # Next we tell the parser to parse the arguments into an args object which
    # we can use to get the values that the user specified.
    args = parser.parse_args()

    # We set up a dictionary to relate the action that the user specified on the
    # command line. A dictionary is a special kind of thing that allows you to
    # look up a value (the "key") and get a value back.
    action = {"create"  : create,
              "extract" : extract,
              "gui"     : gui,
              "install" : install,
    }

    if args.action: # If the user passed an action argument to the program
        log.info(_('Got command: %s' % args.action))    # Some helpful logging
        log.debug('Destination is %s' % args.directory)

        # If the user specified a directory to use, we need to pass it.
        # Otherwise, we need to pass nothing at all.
        if args.directory == None:
            # action[args.action] looks up the value of the key named for what
            # the user gave as ACTION on the command line. It allows us to call
            # the function without having to use a lot of if/else statements.
            action[args.action](log, path=args.file)
        else:
            action[args.action](log, path=args.file, extract_dir=args.directory)

# This tells python that if the program was run by itself, we need to run the
# main() function. This allows us to run the program as a CLI application while
# also letting us import kettle from other programs.
if __name__ == "__main__":
    main()
